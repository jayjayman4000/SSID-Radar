<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SOPHIA Wi-Fi Radar</title>
  <style>
    :root {
      --bg: #020917;
      --panel: #07162d;
      --line: #1b4d88;
      --line-soft: #0d2f58;
      --accent: #2ea4ff;
      --accent-soft: rgba(46, 164, 255, 0.2);
      --text: #c9e8ff;
      --high: #ff4d6d;
      --med: #ffd166;
      --low: #42d392;
    }

    * {
      box-sizing: border-box;
      font-family: "Segoe UI", Tahoma, sans-serif;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, #071a33 0%, var(--bg) 55%);
      color: var(--text);
      min-height: 100vh;
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: 16px;
      padding: 16px;
    }

    .panel {
      background: linear-gradient(180deg, rgba(7, 22, 45, 0.9), rgba(3, 11, 24, 0.95));
      border: 1px solid var(--line-soft);
      border-radius: 12px;
      box-shadow: inset 0 0 30px rgba(0, 102, 255, 0.08);
      overflow: hidden;
    }

    .radar-wrap {
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .hud-title,
    .list-title {
      padding: 14px 16px;
      border-bottom: 1px solid var(--line-soft);
      display: flex;
      justify-content: space-between;
      align-items: center;
      letter-spacing: 0.04em;
      font-weight: 600;
    }

    #radarCanvas {
      width: 100%;
      height: calc(100vh - 110px);
      display: block;
      background: repeating-radial-gradient(circle at center, rgba(46, 164, 255, 0.04) 0 36px, transparent 36px 72px);
    }

    .list-panel {
      display: grid;
      grid-template-rows: auto auto auto auto auto 1fr;
    }

    .stats {
      padding: 10px 16px;
      border-bottom: 1px solid var(--line-soft);
      font-size: 13px;
      color: #9ccff6;
      display: flex;
      justify-content: space-between;
    }

    .controls {
      padding: 10px 16px;
      border-bottom: 1px solid var(--line-soft);
      display: flex;
      gap: 14px;
      align-items: center;
      color: #a8d4f8;
      font-size: 12px;
      flex-wrap: wrap;
    }

    .controls label {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      cursor: pointer;
    }

    .panel-block {
      padding: 10px 16px;
      border-bottom: 1px solid var(--line-soft);
      color: #a8d4f8;
      font-size: 12px;
      display: grid;
      gap: 8px;
    }

    .panel-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .panel-block input[type="number"],
    .panel-block select {
      background: #0a213f;
      color: #d5edff;
      border: 1px solid #1e4c80;
      border-radius: 6px;
      padding: 2px 6px;
    }

    .panel-block button {
      background: #123a66;
      color: #d8eeff;
      border: 1px solid #2f67a3;
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
    }

    .rules-grid {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    #movementCanvas {
      width: 100%;
      height: 120px;
      display: block;
      background: #041426;
      border: 1px solid #1a487a;
      border-radius: 8px;
    }

    .slider-wrap {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .slider-wrap input[type="range"] {
      width: 110px;
    }

    .net-list {
      overflow: auto;
      padding: 8px;
      display: grid;
      gap: 8px;
      align-content: start;
    }

    .net-item {
      border: 1px solid #14406f;
      border-radius: 10px;
      padding: 10px;
      background: rgba(8, 25, 47, 0.8);
      font-size: 12px;
      line-height: 1.35;
    }

    .ssid {
      font-weight: 600;
      color: #d8eeff;
      margin-bottom: 4px;
    }

    .meta {
      color: #9bc9ef;
    }

    .risk {
      font-weight: 700;
    }

    .risk-high { color: var(--high); }
    .risk-med { color: var(--med); }
    .risk-low { color: var(--low); }
  </style>
</head>
<body>
  <section class="panel radar-wrap">
    <header class="hud-title">
      <span>SOPHIA TACTICAL RADAR</span>
      <span id="lastUpdate">--</span>
    </header>
    <canvas id="radarCanvas"></canvas>
  </section>

  <aside class="panel list-panel">
    <header class="list-title">Detected Networks</header>
    <div class="stats">
      <span id="countLabel">0 active</span>
      <span>Live scan</span>
    </div>
    <div class="controls">
      <label><input id="ignoreHome" type="checkbox"> Ignore dorm/home-like</label>
      <label><input id="beepHigh" type="checkbox" checked> Beep on high-risk</label>
      <div class="slider-wrap">
        <span>Zoom</span>
        <input id="zoomSlider" type="range" min="60" max="220" step="10" value="100">
        <span id="zoomValue">1.0x</span>
      </div>
      <span id="audioState">Audio standby</span>
    </div>
    <div class="panel-block">
      <div><strong>Channel Controls</strong> <span id="channelStatus">loading...</span></div>
      <div class="panel-row">
        <label>Band
          <select id="channelMode">
            <option value="2.4GHz">2.4GHz</option>
            <option value="5GHz">5GHz</option>
            <option value="dual">Dual</option>
          </select>
        </label>
        <label>Hop ms <input id="hopMs" type="number" min="120" max="2000" step="10" value="350"></label>
        <label>Lock Ch <input id="lockChannel" type="number" min="0" max="165" value="0"></label>
        <button id="applyChannel">Apply</button>
      </div>
    </div>
    <div class="panel-block">
      <div><strong>Alert Rules</strong></div>
      <div class="panel-row">
        <label>Min RSSI <input id="ruleMinRssi" type="number" min="-100" max="-20" value="-80"></label>
        <label>Min Confidence <input id="ruleMinConfidence" type="number" min="0" max="100" value="45"></label>
      </div>
      <div class="rules-grid">
        <label><input class="rule-cat" type="checkbox" value="FLOCK" checked> FLOCK</label>
        <label><input class="rule-cat" type="checkbox" value="POLICE" checked> POLICE</label>
        <label><input class="rule-cat" type="checkbox" value="CAMERA" checked> CAMERA</label>
        <label><input class="rule-cat" type="checkbox" value="OPEN" checked> OPEN</label>
        <label><input class="rule-cat" type="checkbox" value="GENERAL" checked> GENERAL</label>
      </div>
    </div>
    <div class="panel-block">
      <div><strong>Movement Mode</strong> <span id="movementState">idle</span></div>
      <div class="panel-row">
        <button id="startMovement">Start</button>
        <button id="stopMovement">Stop</button>
        <button id="clearMovement">Clear</button>
      </div>
      <canvas id="movementCanvas"></canvas>
    </div>
    <div id="networkList" class="net-list"></div>
  </aside>

  <script>
    const canvas = document.getElementById('radarCanvas');
    const context = canvas.getContext('2d');
    const listElement = document.getElementById('networkList');
    const countLabel = document.getElementById('countLabel');
    const lastUpdate = document.getElementById('lastUpdate');
    const ignoreHome = document.getElementById('ignoreHome');
    const beepHigh = document.getElementById('beepHigh');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    const audioState = document.getElementById('audioState');
    const channelStatus = document.getElementById('channelStatus');
    const channelMode = document.getElementById('channelMode');
    const hopMs = document.getElementById('hopMs');
    const lockChannel = document.getElementById('lockChannel');
    const applyChannel = document.getElementById('applyChannel');
    const ruleMinRssi = document.getElementById('ruleMinRssi');
    const ruleMinConfidence = document.getElementById('ruleMinConfidence');
    const movementCanvas = document.getElementById('movementCanvas');
    const movementCtx = movementCanvas.getContext('2d');
    const startMovementBtn = document.getElementById('startMovement');
    const stopMovementBtn = document.getElementById('stopMovement');
    const clearMovementBtn = document.getElementById('clearMovement');
    const movementState = document.getElementById('movementState');
    const ruleCategoryBoxes = Array.from(document.querySelectorAll('.rule-cat'));

    let sweepAngle = 0;
    let radarData = [];
    let cursor = -1;
    const alertedHigh = new Set();
    let audioContext = null;
    let zoomFactor = 1.0;
    let channelConfig = null;
    let movementWatchId = null;
    let movementPoints = [];
    let channelFormDirty = false;

    const alertRules = {
      minRssi: -80,
      minConfidence: 45,
      categories: new Set(['FLOCK', 'POLICE', 'CAMERA', 'OPEN', 'GENERAL'])
    };

    const SENSITIVE_CATEGORIES = new Set(['FLOCK', 'POLICE', 'CAMERA']);

    function saveUiSettings() {
      const settings = {
        ignoreHome: ignoreHome.checked,
        beepHigh: beepHigh.checked,
        zoom: zoomSlider.value,
        minRssi: ruleMinRssi.value,
        minConfidence: ruleMinConfidence.value,
        categories: ruleCategoryBoxes.filter((box) => box.checked).map((box) => box.value),
        channelMode: channelMode.value,
        hopMs: hopMs.value,
        lockChannel: lockChannel.value,
      };
      localStorage.setItem('sophiaUiSettings', JSON.stringify(settings));
    }

    function loadUiSettings() {
      try {
        const raw = localStorage.getItem('sophiaUiSettings');
        if (!raw) return;
        const settings = JSON.parse(raw);
        if (typeof settings.ignoreHome === 'boolean') ignoreHome.checked = settings.ignoreHome;
        if (typeof settings.beepHigh === 'boolean') beepHigh.checked = settings.beepHigh;
        if (settings.zoom) zoomSlider.value = settings.zoom;
        if (settings.minRssi) ruleMinRssi.value = settings.minRssi;
        if (settings.minConfidence) ruleMinConfidence.value = settings.minConfidence;
        if (Array.isArray(settings.categories)) {
          const enabled = new Set(settings.categories);
          ruleCategoryBoxes.forEach((box) => { box.checked = enabled.has(box.value); });
        }
        if (settings.channelMode) channelMode.value = settings.channelMode;
        if (settings.hopMs) hopMs.value = settings.hopMs;
        if (settings.lockChannel) lockChannel.value = settings.lockChannel;
      } catch {
      }
    }

    function sizeMovementCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const rect = movementCanvas.getBoundingClientRect();
      movementCanvas.width = rect.width * ratio;
      movementCanvas.height = rect.height * ratio;
      movementCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
    }

    function updateAlertRulesFromUI() {
      alertRules.minRssi = Number(ruleMinRssi.value);
      alertRules.minConfidence = Number(ruleMinConfidence.value);
      alertRules.categories = new Set(ruleCategoryBoxes.filter((box) => box.checked).map((box) => box.value));
    }

    function shouldAlert(network) {
      if (network.risk !== 'HIGH') return false;
      if (network.rssi < alertRules.minRssi) return false;
      if ((network.confidence || 0) < alertRules.minConfidence) return false;
      if (alertRules.categories.size === 0) return false;
      if (alertRules.categories.has(network.category)) return true;
      if (alertRules.categories.has('GENERAL') && !SENSITIVE_CATEGORIES.has(network.category)) return true;
      return false;
    }

    function sizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * ratio;
      canvas.height = rect.height * ratio;
      context.setTransform(ratio, 0, 0, ratio, 0, 0);
    }

    function riskClass(value) {
      if (value === 'HIGH') return 'risk-high';
      if (value === 'MED') return 'risk-med';
      return 'risk-low';
    }

    function drawRadarGrid(cx, cy, radius) {
      context.strokeStyle = 'rgba(46,164,255,0.35)';
      context.lineWidth = 1;
      for (let ring = 1; ring <= 4; ring++) {
        context.beginPath();
        context.arc(cx, cy, (radius / 4) * ring, 0, Math.PI * 2);
        context.stroke();
      }

      context.strokeStyle = 'rgba(46,164,255,0.18)';
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        context.beginPath();
        context.moveTo(cx, cy);
        context.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
        context.stroke();
      }
    }

    function drawSweep(cx, cy, radius) {
      const angle = (sweepAngle * Math.PI) / 180;
      const gradient = context.createRadialGradient(cx, cy, 0, cx, cy, radius);
      gradient.addColorStop(0, 'rgba(46,164,255,0.22)');
      gradient.addColorStop(1, 'rgba(46,164,255,0)');

      context.fillStyle = gradient;
      context.beginPath();
      context.moveTo(cx, cy);
      context.arc(cx, cy, radius, angle - 0.24, angle + 0.24);
      context.closePath();
      context.fill();

      context.strokeStyle = 'rgba(46,164,255,0.7)';
      context.lineWidth = 2;
      context.beginPath();
      context.moveTo(cx, cy);
      context.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
      context.stroke();

      sweepAngle = (sweepAngle + 2) % 360;
    }

    function dotColor(risk) {
      if (risk === 'HIGH') return '#ff4d6d';
      if (risk === 'MED') return '#ffd166';
      return '#42d392';
    }

    function visibleNetworks() {
      if (!ignoreHome.checked) return radarData;
      return radarData.filter((network) => {
        const denseDormLike = (network.same_ssid_count || 1) >= 10;
        if (SENSITIVE_CATEGORIES.has(network.category)) {
          return true;
        }
        return !denseDormLike && network.category !== 'HOME';
      });
    }

    function drawTargets(cx, cy, radius) {
      visibleNetworks().forEach((network) => {
        const angle = (network.angle * Math.PI) / 180;
        const scaledDistance = Math.min(network.normalized_distance * zoomFactor, 1.0);
        const r = scaledDistance * radius;
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;

        context.fillStyle = dotColor(network.risk);
        context.beginPath();
        context.arc(x, y, 4, 0, Math.PI * 2);
        context.fill();

        context.fillStyle = 'rgba(201,232,255,0.9)';
        context.font = '11px Segoe UI';
        context.fillText(network.ssid.slice(0, 14), x + 8, y - 8);
      });
    }

    function render() {
      const width = canvas.getBoundingClientRect().width;
      const height = canvas.getBoundingClientRect().height;
      context.clearRect(0, 0, width, height);

      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) * 0.44;

      drawRadarGrid(cx, cy, radius);
      drawSweep(cx, cy, radius);
      drawTargets(cx, cy, radius);

      requestAnimationFrame(render);
    }

    function renderList(networks) {
      if (!networks.length) {
        const hiddenCount = Math.max(0, radarData.length - networks.length);
        const emptyMessage = hiddenCount > 0
          ? `No networks match current filters (${hiddenCount} hidden).`
          : 'No beacons captured yet.';
        listElement.innerHTML = `<div class="net-item">${emptyMessage}</div>`;
        return;
      }

      listElement.innerHTML = networks.map((network) => `
        <article class="net-item">
          <div class="ssid">${network.ssid}</div>
          <div class="meta">BSSID: ${network.bssid}</div>
          <div class="meta">RSSI: ${network.rssi} dBm (stable ${network.rssi_stable ?? network.rssi} dBm) • Dist≈ ${network.distance} m • Ch: ${network.channel}</div>
          <div class="meta">Crypto: ${network.crypto} • Type: ${network.category} • SSID Count: ${network.same_ssid_count || 1}</div>
          <div class="meta">Confidence: ${network.confidence || 0}% • Seen: ${network.sightings || 1}</div>
          <div class="risk ${riskClass(network.risk)}">Risk: ${network.risk}</div>
        </article>
      `).join('');
    }

    function refreshFilteredView(totalCount) {
      const visible = visibleNetworks();
      const total = Number.isInteger(totalCount) ? totalCount : radarData.length;
      const hidden = Math.max(0, total - visible.length);
      countLabel.textContent = `${visible.length} shown / ${total} active (${hidden} hidden)`;
      renderList(visible);
    }

    function ensureAudioContext() {
      if (!audioContext) {
        const Context = window.AudioContext || window.webkitAudioContext;
        if (!Context) {
          audioState.textContent = 'Audio unavailable';
          return null;
        }
        audioContext = new Context();
      }
      return audioContext;
    }

    function beep() {
      const ctx = ensureAudioContext();
      if (!ctx) return;
      if (ctx.state === 'suspended') {
        ctx.resume().catch(() => {});
      }

      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(900, ctx.currentTime);
      gainNode.gain.setValueAtTime(0.0001, ctx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.18, ctx.currentTime + 0.02);
      gainNode.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.18);
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      oscillator.start();
      oscillator.stop(ctx.currentTime + 0.2);
    }

    function maybeAlertHighRisk(networks) {
      if (!beepHigh.checked) return;

      let shouldBeep = false;
      networks.forEach((network) => {
        if (shouldAlert(network) && !alertedHigh.has(network.bssid)) {
          alertedHigh.add(network.bssid);
          shouldBeep = true;
        }
      });

      if (shouldBeep) {
        beep();
      }
    }

    function renderMovementMap() {
      const width = movementCanvas.getBoundingClientRect().width;
      const height = movementCanvas.getBoundingClientRect().height;
      movementCtx.clearRect(0, 0, width, height);

      if (movementPoints.length < 2) {
        movementCtx.fillStyle = 'rgba(155, 201, 239, 0.8)';
        movementCtx.font = '12px Segoe UI';
        movementCtx.fillText('Movement path appears here', 10, 20);
        return;
      }

      const lats = movementPoints.map((p) => p.lat);
      const lons = movementPoints.map((p) => p.lon);
      const minLat = Math.min(...lats);
      const maxLat = Math.max(...lats);
      const minLon = Math.min(...lons);
      const maxLon = Math.max(...lons);
      const latSpan = Math.max(0.00001, maxLat - minLat);
      const lonSpan = Math.max(0.00001, maxLon - minLon);

      const project = (point) => {
        const x = ((point.lon - minLon) / lonSpan) * (width - 16) + 8;
        const y = height - ((((point.lat - minLat) / latSpan) * (height - 16)) + 8);
        return { x, y };
      };

      movementCtx.strokeStyle = '#2ea4ff';
      movementCtx.lineWidth = 2;
      movementCtx.beginPath();
      movementPoints.forEach((point, index) => {
        const { x, y } = project(point);
        if (index === 0) movementCtx.moveTo(x, y);
        else movementCtx.lineTo(x, y);
      });
      movementCtx.stroke();

      const first = project(movementPoints[0]);
      const last = project(movementPoints[movementPoints.length - 1]);
      movementCtx.fillStyle = '#42d392';
      movementCtx.beginPath();
      movementCtx.arc(first.x, first.y, 4, 0, Math.PI * 2);
      movementCtx.fill();
      movementCtx.fillStyle = '#ff4d6d';
      movementCtx.beginPath();
      movementCtx.arc(last.x, last.y, 4, 0, Math.PI * 2);
      movementCtx.fill();
    }

    async function refreshMovementPoints() {
      try {
        const response = await fetch('/api/movement');
        const data = await response.json();
        movementPoints = data.points || [];
        renderMovementMap();
      } catch {
      }
    }

    function strongestNetwork() {
      if (!radarData.length) return null;
      return radarData[0];
    }

    async function postMovementPoint(lat, lon) {
      const top = strongestNetwork();
      await fetch('/api/movement', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          lat,
          lon,
          top_bssid: top?.bssid || null,
          top_ssid: top?.ssid || null,
          top_rssi: top?.rssi ?? null,
        }),
      });
    }

    function stopMovementMode() {
      if (movementWatchId !== null) {
        navigator.geolocation.clearWatch(movementWatchId);
        movementWatchId = null;
      }
      movementState.textContent = 'idle';
    }

    function startMovementMode() {
      if (!navigator.geolocation) {
        movementState.textContent = 'geolocation unavailable';
        return;
      }
      if (movementWatchId !== null) return;
      movementState.textContent = 'tracking';
      movementWatchId = navigator.geolocation.watchPosition(
        (position) => {
          postMovementPoint(position.coords.latitude, position.coords.longitude)
            .then(() => refreshMovementPoints())
            .catch(() => {
              movementState.textContent = 'movement post failed';
            });
        },
        () => {
          movementState.textContent = 'location permission denied';
          stopMovementMode();
        },
        { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 },
      );
    }

    async function clearMovement() {
      try {
        await fetch('/api/movement', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ clear: true }),
        });
      } catch {
      }
      movementPoints = [];
      renderMovementMap();
    }

    async function applyChannelConfig() {
      const payload = {
        mode: channelMode.value,
        enabled: true,
        hop_delay: Number(hopMs.value) / 1000,
        locked_channel: Number(lockChannel.value) > 0 ? Number(lockChannel.value) : null,
      };

      try {
        const response = await fetch('/api/channel', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        channelConfig = await response.json();
        channelFormDirty = false;
        refreshChannelUI();
        saveUiSettings();
      } catch {
        channelStatus.textContent = 'channel update failed';
      }
    }

    function refreshChannelUI() {
      if (!channelConfig) return;
      if (!channelFormDirty) {
        channelMode.value = channelConfig.mode || '2.4GHz';
        hopMs.value = String(Math.round((channelConfig.hop_delay || 0.35) * 1000));
        lockChannel.value = channelConfig.locked_channel || 0;
      }
      const lockText = channelConfig.locked_channel ? `locked ${channelConfig.locked_channel}` : 'hopping';
      const current = channelConfig.current_channel ? `ch ${channelConfig.current_channel}` : 'ch ?';
      const pending = channelFormDirty ? ' • pending changes' : '';
      channelStatus.textContent = `${current} • ${lockText}${pending}`;
    }

    function ingestPayload(data) {
      radarData = data.networks || [];
      cursor = Number.isInteger(data.version) ? data.version : cursor;
      channelConfig = data.channel || channelConfig;
      refreshFilteredView(data.count || 0);
      maybeAlertHighRisk(radarData);
      refreshChannelUI();
      lastUpdate.textContent = new Date().toLocaleTimeString();
    }

    async function fetchData() {
      try {
        const response = await fetch('/api/networks');
        ingestPayload(await response.json());
      } catch {
        countLabel.textContent = 'Connection error';
      }
    }

    async function longPollLoop() {
      while (true) {
        try {
          const response = await fetch(`/api/networks/longpoll?since=${cursor}&timeout=25`);
          ingestPayload(await response.json());
        } catch {
          countLabel.textContent = 'Connection error';
          await new Promise((resolve) => setTimeout(resolve, 1200));
        }
      }
    }

    sizeCanvas();
    sizeMovementCanvas();
    loadUiSettings();
    window.addEventListener('resize', sizeCanvas);
    window.addEventListener('resize', sizeMovementCanvas);
    window.addEventListener('pointerdown', () => {
      const ctx = ensureAudioContext();
      if (ctx) {
        ctx.resume().then(() => {
          audioState.textContent = 'Audio armed';
        }).catch(() => {});
      }
    }, { once: true });
    ignoreHome.addEventListener('change', () => {
      refreshFilteredView(radarData.length);
      saveUiSettings();
    });
    beepHigh.addEventListener('change', () => {
      audioState.textContent = beepHigh.checked ? 'Audio armed' : 'Audio muted';
      saveUiSettings();
    });
    applyChannel.addEventListener('click', applyChannelConfig);
    channelMode.addEventListener('change', () => {
      channelFormDirty = true;
      saveUiSettings();
      refreshChannelUI();
    });
    hopMs.addEventListener('input', () => {
      channelFormDirty = true;
      saveUiSettings();
      refreshChannelUI();
    });
    lockChannel.addEventListener('input', () => {
      channelFormDirty = true;
      saveUiSettings();
      refreshChannelUI();
    });
    ruleMinRssi.addEventListener('input', () => {
      updateAlertRulesFromUI();
      saveUiSettings();
    });
    ruleMinConfidence.addEventListener('input', () => {
      updateAlertRulesFromUI();
      saveUiSettings();
    });
    ruleCategoryBoxes.forEach((box) => box.addEventListener('change', () => {
      updateAlertRulesFromUI();
      saveUiSettings();
    }));
    startMovementBtn.addEventListener('click', startMovementMode);
    stopMovementBtn.addEventListener('click', stopMovementMode);
    clearMovementBtn.addEventListener('click', clearMovement);
    zoomSlider.addEventListener('input', () => {
      zoomFactor = Number(zoomSlider.value) / 100;
      zoomValue.textContent = `${zoomFactor.toFixed(1)}x`;
      saveUiSettings();
    });
    zoomFactor = Number(zoomSlider.value) / 100;
    zoomValue.textContent = `${zoomFactor.toFixed(1)}x`;
    updateAlertRulesFromUI();
    refreshMovementPoints();
    setInterval(refreshMovementPoints, 8000);
    render();
    fetchData();
    longPollLoop();
  </script>
</body>
</html>